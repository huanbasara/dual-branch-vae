# dual-branch-vae
用于训练双分支VAE模型，用于SVG路径生成

## 背景
本项目需要在Google Colab上运行VAE训练逻辑，但VAE训练的数据处理依赖于PyDiffVG库。由于PyDiffVG在Colab环境中安装困难（需要CUDA、C++编译环境），我们采用了纯Python替代方案。

## PyDiffVG的作用

### 在整个项目中的功能
1. **正向转换**: SVG → 坐标点序列(Tensor)
2. **反向渲染**: 坐标点序列 → 贝塞尔曲线拟合 → 平滑SVG渲染
3. **可微分渲染**: 支持梯度反传，用于VSD优化

### 使用场景
- **VAE训练**: 只需正向转换，将SVG解析为坐标点供模型学习
- **VSD优化**: 需要完整PyDiffVG，进行反向渲染生成图像与文本对比

## 我们的解决方案

### pydiffvg_lite模块
实现了PyDiffVG的纯Python核心功能：
- `svg_to_scene()`: SVG解析为坐标点
- `Path`, `Circle`等形状类: 几何对象表示
- 渲染函数的Dummy实现: 满足接口兼容性

### 转换逻辑示例
```python
# SVG路径指令
"M0 1585 l0 -335 30 0 30 0 2 173..."

# 转换为坐标点
tensor([[0.0, 33.5], [0.0, 67.0], [3.0, 67.0], [6.0, 67.0], [6.2, 49.7], ...])
```

## 技术限制说明

### ✅ 纯Python可实现
- **SVG解析**: 解读路径指令，提取控制点
- **坐标变换**: 缩放、平移、归一化
- **数据格式化**: 转换为VAE可处理的Tensor格式

### ❌ 必须依赖C++
- **贝塞尔曲线重建**: 从离散点拟合平滑曲线
- **高性能渲染**: GPU加速的像素级渲染
- **抗锯齿处理**: 复杂的图像平滑算法
- **可微分计算**: 高效梯度反传

## 项目适配
本项目专注于VAE训练，只需要正向转换功能，因此pydiffvg_lite足以满足需求。对于需要完整渲染功能的场景，仍需安装完整的PyDiffVG。
